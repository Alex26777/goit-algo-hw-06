import networkx as nx

# Створення графа та додавання вершин та ребер згідно з першим завданням
G = nx.Graph()
G.add_nodes_from(["Станція 1", "Станція 2", "Станція 3", "Станція 4", "Станція 5"])
G.add_edges_from([("Станція 1", "Станція 2"), ("Станція 2", "Станція 3"), 
                  ("Станція 3", "Станція 4"), ("Станція 4", "Станція 5"), 
                  ("Станція 5", "Станція 1"), ("Станція 2", "Станція 4")])

# Визначаємо початкову та кінцеву точки
start = "Станція 1"
end = "Станція 5"

# DFS (пошук в глибину)
dfs_path = nx.dfs_path(G, start, end)
print(f"DFS шлях від {start} до {end}: {dfs_path}")

# BFS (пошук в ширину)
bfs_path = nx.bfs_path(G, start, end)
print(f"BFS шлях від {start} до {end}: {bfs_path}")

# Аналіз різниці в отриманих шляхах
# Для DFS
print("DFS відвідує вершини, йдучи якомога глибше в графі перед тим, як зворотити,")
print("що може призвести до більш довгого шляху в широких графах.")

# Для BFS
print("BFS відвідує вершини рівень за рівнем, тому часто знаходить найкоротший шлях")
print("в не зважених графах.")

# Висновок: DFS може бути неефективним у широких графах, де як BFS так і DFS знаходять шляхи,
# але шлях знайдений за допомогою BFS буде найкоротшим.